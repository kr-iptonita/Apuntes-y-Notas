\section{Considerar el siguiente problema}

\textbf{Cambio de Base}
\textsc{Dado un número en base $6$ convertirlo a binario, la entrada es un arreglo de digitos en base $6$ y la salida es un arreglo de bits}

\subsection{Diseñar usando Inducción Matematica un algoritmo eficiente que solucione el problema y que use el 
menor número de comparaciones}
\textbf{Caso Base}: Podemos ver que para el caso base de $n = 0$, la representación binaria es $0$, lo cual es cierto. 
Para el caso base de $n = 1$, la representación binaria es $1$, lo cual también es cierto.\\ 
\textbf{Hipotesis}: Supongamos que la afirmación es cierta para todos los números en base $6$ menores que $n$. \\
\textbf{Paso Inductivo}: Si $n$ es impar, entonces $n = 2k + 1$ para algún $k$. Entonces, la representación binaria de $n$
es la misma que la de $k$, seguida de un $1$. Pero $k$ es menor que $n$ y, por lo tanto, la afirmación es cierta para $k$. 
Por lo tanto, la representación binaria de $k$ se puede calcular utilizando el proceso recursivo, y la representación binaria de
$n$ es simplemente la de $k$ seguida de un $1$. Por lo tanto, la afirmación es cierta para $n$.


Finalmente obtenemos el siguiente algoritmo

\begin{lstlisting}[language=python]

convertir_a_binario(numero_en_base_6):
    if numero_en_base_6 == 0:
        return [0]
    elif numero_en_base_6 == 1:
        return [1]
    else:
      cociente = numero_en_base_6 // 2
      resto = numero_en_base_6 % 2
      representacion_binaria_cociente = convertir_a_binario(cociente)
      if resto == 0:
        representacion_binaria_cociente.append(0)
      else:
        representacion_binaria_cociente.append(1)
      
      return representacion_binaria_cociente
\end{lstlisting}

\subsection{Determinar la complejidad del algoritmo obtenido}

La complejidad temporal del algoritmo que diseñamos para convertir un número en base $6$ a binario utilizando el proceso recursivo es de $O(\log n)$, donde $n$ es el número en base $6$.

Esto se debe a que en cada llamada recursiva, el número en base $6$ se divide por $2$ (es decir, se divide por $6$ y se redondea hacia abajo), lo que reduce su tamaño a la mitad. Como resultado, el número de llamadas recursivas necesarias para convertir el número completo a binario es $\log_2(n)$, lo que da lugar a la complejidad temporal de $O(\log n)$.
